// https://docs.rs/futures/latest/futures/index.html
// use futures:: {executor::*};
use futures::	{executor, executor::ThreadPool};
use futures::	{channel::mpsc, stream::StreamExt};

pub fn futures_ex() {
  let pool    	= ThreadPool::new().expect("Failed to build pool");
  let (tx, rx)	= mpsc::unbounded::<i32>();

  let fut_values = async { // Create a future by an async block, where async is responsible for an implementation of Future. At this point no executor has been provided to this future, so it will not be running
    let fut_tx_result = async move { // Create another async block, again where the Future implementation is generated by async. Since this is inside of a parent async block, it will be provided with the executor of the parent block when the parent block is executed.
      // This executor chaining is done by Future::poll whose second argument is a std::task::Context. This represents our executor, and the Future implemented by this async block can be polled using the parent async block's executor.
      (0..100).for_each(|v| {
        tx.unbounded_send(v).expect("Failed to send");
      })
    };

    pool.spawn_ok(fut_tx_result); // Use the provided thread pool to spawn the generated future responsible for transmission

    let fut_values = rx
      .map(|v| v * 2) // trait StreamExt: Stream { fn map<T,F>(self, f:F) -> Map<Self, F> where F:FnMut(Self::Item) -> T
      .collect();

    fut_values.await // Use the executor provided to this async block to wait for the future to complete.
  };

  let values: Vec<i32> = executor::block_on(fut_values); // Actually execute the above future, which will invoke Future::poll and subsequently chain appropriate Future::poll and methods needing executors to drive all futures. Eventually fut_values will be driven to completion.

  println!("Values={:?}", values);
}
